\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{xcolor}
\usetheme{Warsaw}

\title{Reset controller framework: how to use it}
\author{Romain Perier}
\institute{Embedded linux engineer and foss developer\newline romain.perier@gmail.com}
\date{December 3th 2015}

\begin{document}

\begin{frame}
\titlepage{}
\end{frame}

\begin{frame}{Romain Perier}
	\begin{itemize}
		\item Embedded linux engineer since 2012
		\item Mainline linux kernel and yocto contributor (Rockchip, Meson)
		\item Maintainer of meta-rockchip in the yocto project
		\item Living in Toulouse, France
	\end{itemize}
\end{frame}

\begin{frame}{Overview}
	\begin{itemize}
		\item Hardware reset controller
		\item What is the reset controller framework
		\item How to add your own reset controller driver
		\item How to interface it with the devicetree
		\item Use reset lines from device drivers
	\end{itemize}
\end{frame}

\begin{frame}{Hardware reset controller}
	\begin{itemize}
		\item A system reset controller includes resets: generated by hardware, watchdog, or software
		\item On some SoCs devices include a reset line that is driven by a reset system
		\item Some IP blocks have the ability to reset their clock domains or do internal initializations when its reset line is asserted/deasserted
		\item It is strongly platform dependent, but you might have to generate software resets for powering peripherals
		\item you might have to generate software resets to powering off peripherals
	\end{itemize}
\end{frame}

\begin{frame}{What is the reset controller framework}
	\begin{itemize}
		\item Started by Philipp Zabel in 2013
		\item That is a framework to abstract reset signals handling inside the kernel
		\item All the platform dependent parts about how to assert or deassert a specific reset line is handled internally on the provider side
		\item Allow to declare reset lines and to provide these lines to the device driver throught the Device Tree
		\item Like many other frameworks it is based on the consumer/provider software architecture
	\end{itemize}
\end{frame}

\begin{frame}{Diagram overview of the reset subsystem architecture}
	\centering
	\includegraphics[scale=0.4]{reset_framework_architecture.png}
\end{frame}

\begin{frame}{Interface of the reset framework}
	You have type of interfaces:
	\begin{itemize}
		\item The one used by the reset controller driver, in \textcolor{gray}{include/linux/reset-controller.h}:
			\begin{itemize}
				%\item Defined in \textcolor{gray}{include/linux/reset-controller.h}
				\item \textit{reset\_controller\_register}: register your reset system to the kernel
				\item \textit{\textcolor{blue}{struct} reset\_control\_ops}: operations invoked by the RCF, containing callbacks implemented by your driver
				\item \textit{\textcolor{blue}{struct} reset\_controller\_dev}: data structure of the reset system driver that is going to be registered to the kernel
			\end{itemize}
	\end{itemize}
	\begin{itemize}
		\item The one used by devices drivers, in \textcolor{gray}{include/linux/reset.h}:
			\begin{itemize}
				%\item Defined in \textcolor{gray}{include/linux/reset.h}
				\item \textit{\textcolor{blue}{struct} reset\_control}: data structure corresponding to the reset line being used by the consumer
				\item \textit{reset\_control\_reset}: does all required things to reset the device connected to this signal (self-asserting/deasserting)
				\item \textit{reset\_control\_assert}: manually asserts the reset line
				\item \textit{reset\_control\_status}: get the status of the reset line
			\end{itemize}
	\end{itemize}
\end{frame}

\end{document}
